 mutex 
            когда поток пытается захватить заблокированный мьютекс:
                он блокируется и переводится в состояние ожидания (sleep)
                управление передается ядру ОС -> не тратит CPU
            когда мьютекс освобождается (какой-то второй поток который держал мьютекс его разблокирует):
                ОС пробуждает наш ожидающий поток (wake up)
                при получении кванта времени поток продолжит выполнение
            ! использует сискол futex -> требуется переключение контекста. (НО не потребляет CPU пока спит)

        spinlock
            когда поток пытается захватить заблокированный спинлок:
                поток продолжает в цикле проверять состояние лока и пытается заблокировать (значит другой поток не может занять его место)
                не освобождает CPU
            ! работает полностью в user space -> не требует переключения контекста
            ! 100% загрузка ядра CPU из-за цикла ожидания блокировки
 обобщение:
            при заблокированном мьютексе поток переводится в сон; при заблокированном локе поток постоянно пытается разблокировать.
            мьютекс использует сисколы, спинлок - нет. 
            при спящем мьютексе ОС передает ядро активному потоку, при спинлоке долбящийся поток продолжит занимать ядро.
 // Проверяем: если *uaddr != val, возвращаемся сразу
    // Иначе: добавляем поток в очередь ожидания
    // Переводим поток в состояние SLEEP
    // ПЕРЕКЛЮЧЕНИЕ КОНТЕКСТА - другой поток получает CPU
// Будим nr_wake потоков из очереди ожидания
    // Переводим их в состояние READY
    // Планировщик решит, когда они получат CPU
 ---------------------------------------------------------------------------------------------------------------------------------------
mutex + условные переменные
int queue_add(queue_t *q, int val) {
    pthread_mutex_lock(&q->lock);
    q->add_attempts++;
    
    // ЖДЁМ, пока очередь не станет НЕ полной
    while (q->count == q->max_count) {
        pthread_cond_wait(&q->not_full, &q->lock);
          // 1. АТОМАРНО: разблокировать mutex
          // 2. Перейти в состояние ОЖИДАНИЯ на cond
          // 3. Когда получим сигнал: 
          //    - проснуться
          //    - АТОМАРНО: захватить mutex снова
          //    - вернуться из функции
    }
    
    // ... добавление элемента
    
    // Сигнал читателю: "Очередь не пуста!"
    pthread_cond_signal(&q->not_empty);
    pthread_mutex_unlock(&q->lock);
    return 1;
}

? Почему нельзя использовать 1 кондвар вместо 2?
    - при наличии двух кондваров потоки writer() блокировались по кондвару q->not_full:
        while (q->count == q->max_count) {
            pthread_cond_wait(&q->not_full, &q->lock);
        }
        , а reader() по кондвару q->not_empty:
        while (q->count == 0) {
            pthread_cond_wait(&q->not_empty, &q->lock);
        }
        , сейчас имею только один кондвар (назову q->cond_var), значит больше не имею возможности
        будить конкретный поток reader() или writer(), значит будим все ожидающие потоки 
        с помощью pthread_cond_broadcast() (тем самым теряю возможность адресно разбудить нужный тип потоков).
        
        Это значит что при добавлении узла теперь будятся не только reader(), но и writer() потоки, что
        мало того что бессмысленно, но и чревато доп тратой CPU с лишними переключениями контекста.

        пример: 
            дано: 2 writer(), 2 reader()
            writer1() добавил элемент в очередь и вызвал pthread_cond_broadcast(&q->cond_var, &q->lock)
            reader1() проснется, захватит мьютекс и заберет 1 узел
            reader2() проснется и увидит что очередь пустая (нахуя будили)
            writer2() только создает конкуренцию за мьютекс (нахуя будили) 
 ---------------------------------------------------------------------------------------------------------------------------------------
mutex + семафоры
